#pragma once

#include "core/identifier_64.hpp"
#include "utilities/spch.hpp"


namespace siren::core
{

class Device;

/**
 * @class RenderResourceID
 * @brief Defines a proxy handle to the underlying API's handle.
 * @tparam Resource The GpuResource for which to define a Handle.
 */
template <typename Resource>
class RenderResourceID final : public Identifier64<RenderResourceID<Resource>> {
    using Base = Identifier64<RenderResourceID<Resource>>;

public:
    using IndexType      = Base::IndexType;
    using GenerationType = Base::GenerationType;

    RenderResourceID(
        const IndexType index,
        const GenerationType gen
    ) : Base(index, gen, 0) { }

    RenderResourceID() : Base() { }
};

/**
 * @brief Simple base struct to identify render resources.
 * Enforces disabling copies on all RenderResource's, as well
 * as provides access to the Device.
 */
template <typename Resource>
class RenderResource {
public:
    friend class Device;

    RenderResource() = default;
    RenderResource(
        Device* device,
        RenderResourceID<Resource> handle
    ) : m_device(device), m_handle(handle) { }

    RenderResource(const RenderResource&)            = delete;
    RenderResource& operator=(const RenderResource&) = delete;
    RenderResource(RenderResource&& other) noexcept
        : m_device(std::exchange(other.m_device, nullptr)), m_handle(std::exchange(other.m_handle, { })) { }
    RenderResource& operator=(RenderResource&& other) noexcept {
        if (this != &other) {
            m_device = std::exchange(other.m_device, nullptr);
            m_handle = std::exchange(other.m_handle, { });
        }
        return *this;
    }

    /// @brief Returns the underlying native handle for this resource.
    auto handle() const noexcept -> RenderResourceID<Resource> { return m_handle; }

protected:
    ~RenderResource() = default;

    Device* m_device;                    ///< @brief Pointer to the render device.
    RenderResourceID<Resource> m_handle; ///< @brief Native handle for the underlying backend.
};

struct Nothing { };

/**
 * @class RenderResourceTable
 * @brief Manages mapping RenderResourceID's (siren proxy handles) to the
 * graphics API's handles.
 * @tparam T The API's handle type aka GLuint or VkBuffer etc.
 * @tparam Resource The siren resource being managed.
 * @tparam Extra Some additional data to store with each resource.
 * @note We store some resource related items in the table since they
 * are API specific, and thus the Siren objects would need to be specialized.
 */
template <typename T, typename Resource, typename Extra = Nothing>
class RenderResourceTable {
public:
    using ApiHandleType   = T;
    using ProxyHandleType = RenderResourceID<Resource>;

private:
    using IndexType      = ProxyHandleType::IndexType;
    using GenerationType = ProxyHandleType::GenerationType;

    /// @brief Struct used for storing resource data.
    struct TableEntry {
        ApiHandleType api_handle  = 0;   ///< @brief The actual api handle.
        GenerationType generation = 0;   ///< @brief The generation of this resource's slot.
        Extra extra               = { }; ///< @brief Some

        // @formatter:off
        void kill() { ++generation; api_handle = 0; extra = Extra{ }; }
        // @formatter:on
    };

public:
    /// @brief Creates and returns a new proxy handle with no api handle associated with it.
    [[nodiscard]]
    auto reserve() -> ProxyHandleType {
        IndexType index;

        if (!m_free_list.empty()) {
            // there's a free index,
            index = m_free_list.back();
            m_free_list.pop_back();
        } else {
            // fetch a new index
            index = static_cast<IndexType>(m_table.size());
            m_table.emplace_back(); // grow table to avoid arr index errors
        }

        TableEntry& table_entry = m_table[index];

        return ProxyHandleType{ index, table_entry.generation };
    }

    /// @brief Takes a proxy handle (should be generated by this table), and associates it with the api handle.
    auto link(
        const ProxyHandleType proxy_handle,
        const ApiHandleType api_handle,
        const Extra extra = { }
    ) -> void {
        SIREN_ASSERT(is_valid_id(proxy_handle), "Passed an invalid ProxyHandleType: {}", proxy_handle);
        auto& table_entry      = m_table[proxy_handle.index()];
        table_entry.api_handle = api_handle;
        table_entry.extra      = extra;
    }

    /// @brief Frees the proxy handle.
    auto release(const ProxyHandleType proxy_handle) -> void {
        SIREN_ASSERT(is_valid_id(proxy_handle), "Cannot free an invalid ProxyHandleType: {}", proxy_handle);
        TableEntry& table_entry = m_table[proxy_handle.index()];
        m_free_list.emplace_back(proxy_handle.index());
        table_entry.kill();
    }

    /// @brief Gets the api handle associated with this proxy handle iff valid.
    [[nodiscard]]
    auto fetch(const ProxyHandleType proxy_handle) -> ApiHandleType {
        if (!is_valid_id(proxy_handle)) { return ApiHandleType{ 0 }; }
        return m_table[proxy_handle.index()].api_handle;
    }

    /// @brief Gets the extra data associated with this proxy.
    [[nodiscard]]
    auto extra(const ProxyHandleType proxy_handle) -> Extra {
        if (!is_valid_id(proxy_handle)) { return ApiHandleType{ 0 }; }
        return m_table[proxy_handle.index()].extra;
    }

private:
    auto is_valid_id(const ProxyHandleType proxy_handle) const -> bool {
        if (proxy_handle.index() >= m_table.size() || !proxy_handle.is_valid()) { return false; }
        const auto& entry = m_table[proxy_handle.index()];
        return entry.generation == proxy_handle.generation();
    }

    std::vector<TableEntry> m_table;    ///< @brief The stored API handles with generation counting.
    std::vector<IndexType> m_free_list; ///< @brief Any free indices to use.
};

} // namespace siren::core
