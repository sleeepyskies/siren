#pragma once

#include "asset_id.hpp"
#include "asset_path.hpp"


namespace siren::core
{

/**
 * @brief The base asset class.
 *
 * Provides no functionality, other than being a label to identify if an
 * object is an asset or not. This is used by the AssetServer and AssetPools
 * to ensure type safety and prevent loading of non-asset types.
 */
struct Asset { };

/**
 * @brief Ensures that A is derived from Asset.
 */
template <typename A>
concept IsAsset = std::derived_from<A, Asset>;

/// @brief Base AssetPool class used for polymorphism.
class AssetPoolBase {
public:
    virtual ~AssetPoolBase() = 0;
};

/**
 * @brief The means of asset storage in siren. Manages
 * asset lifetime as well as providing AssetID's and AssetHandle's.
 *
 * @tparam A The asset type this pool stores.
 */
template <IsAsset A>
class AssetPool final : public AssetPoolBase {
public:
    using GenerationType = AssetID::GenerationType;
    using IndexType      = AssetID::IndexType;
    using TypeID         = AssetID::TypeID;
    using RefCount       = u32;

    ~AssetPool() override = default;

private:
    friend class AssetServer;
    friend class LoadContext;

    /// @brief A storage element in the AssetPool.
    struct PoolEntry {
        std::unique_ptr<A> asset  = nullptr; ///< @brief The stored asset.
        GenerationType generation = 0;       ///< @brief The generation of this storage slot. Useful for reusing slots.
        RefCount ref_count        = 0;       ///< @brief The number of handles referencing this asset.

        // @formatter:off
        void kill() { asset.reset(nullptr); generation++; ref_count = 0; }
        // @formatter:on
    };

    /// @brief The AssetPool's data.
    struct AssetPoolData {
        std::vector<PoolEntry> storage;   ///< @brief Dense asset storage.
        std::vector<IndexType> free_list; ///< @brief Indices that have been freed and should be used.
    };

public:
    /// @brief Creates a new AssetID for this pool, as well as allocates it a storage slot.
    [[nodiscard]]
    auto reserve() -> AssetID {
        IndexType idx;

        if (!m_data.free_list.empty()) {
            idx = m_data.free_list.back();
            m_data.free_list.pop_back();
        } else {
            idx = static_cast<IndexType>(m_data.storage.size());
            m_data.storage.emplace_back(); // grow storage so we don't mess array indexing up
        }

        auto& pool_entry     = m_data.storage[idx];
        pool_entry.asset     = nullptr;
        pool_entry.ref_count = 0;

        return AssetID{ idx, pool_entry.generation, AssetID::get_type_id<A>() };
    }

    /// @brief Adds an asset and takes ownership.
    [[nodiscard]]
    auto add(std::unique_ptr<A>&& asset) -> AssetID {
        const AssetID id = reserve();
        PoolEntry& entry = m_data.storage[id.index()];
        entry.asset      = std::move(asset);
        return id;
    }

    /// @brief Stores an asset into this pool and associates it with the given AssetID.
    /// The ID should be generated by this pool.
    auto link(const AssetID id, std::unique_ptr<A>&& asset) -> void {
        SIREN_ASSERT(is_valid_id(id), "Invalid AssetID passed: {}", id);
        PoolEntry& entry = m_data.storage[id.index()];
        entry.asset      = std::move(asset);
    }

    /// @brief Returns the asset associated with the given ID, or nullptr.
    [[nodiscard]]
    auto fetch(const AssetID id) const -> A* {
        if (!is_valid_id(id)) { return nullptr; }
        const PoolEntry& entry = m_data.storage[id.index()];
        return entry.asset.get();
    }

private:
    template <typename>
    friend class StrongHandle;

    auto is_valid_id(const AssetID id) const -> bool {
        if (id.index() >= m_data.storage.size() || !id.is_valid()) { return false; }
        const auto& entry = m_data.storage[id.index()];
        return entry.generation == id.generation();
    }

    auto inc_ref(const AssetID id) -> void {
        if (!is_valid_id(id)) { return; }
        PoolEntry& entry = m_data.storage[id.index()];
        entry.ref_count += 1;
    }

    auto dec_ref(const AssetID id) -> void {
        if (!is_valid_id(id)) { return; }

        PoolEntry& entry = m_data.storage[id.index()];
        if (entry.generation != id.generation()) { return; }

        // todo: we should maybe emit an AssetCleanupEvent? need to handle destruction here an in asset server eventually
        entry.ref_count -= 1;
        if (entry.ref_count == 0) {
            m_data.free_list.emplace_back(id.index());
            entry.kill();
        }
    }

    AssetPoolData m_data;
};

/**
 * @brief A weak, type erased asset handle.
 * @todo A promote function would be nice, but I cant be bothered to deal with shitty cpp circular headaches rn.
 */
class WeakHandle {
public:
    using TypeID = AssetID::TypeID;

    WeakHandle() = default;
    WeakHandle(const AssetID id, AssetPoolBase* pool, const AssetPath& path) : m_path(path), m_id(id), m_pool(pool) { }

    static auto invalid() -> WeakHandle { return WeakHandle{ }; }

    WeakHandle(const WeakHandle&)            = default;
    WeakHandle& operator=(const WeakHandle&) = default;
    WeakHandle(WeakHandle&&)                 = default;
    WeakHandle& operator=(WeakHandle&&)      = default;

    [[nodiscard]]
    constexpr auto id() const noexcept -> AssetID { return m_id; }
    [[nodiscard]]
    constexpr auto pool() const noexcept -> AssetPoolBase* { return m_pool; }
    [[nodiscard]]
    constexpr auto path() const noexcept -> AssetPath { return m_path; }

    [[nodiscard]]
    constexpr auto operator==(const WeakHandle& other) const -> bool { return id() == other.id(); }

private:
    AssetPath m_path{ };              ///< @brief The path to the referenced asset.
    AssetID m_id{ };                  ///< @brief The raw untyped handle.
    AssetPoolBase* m_pool{ nullptr }; ///< @brief The pool this handles asset belongs to.
};

/**
 * @brief A typed strong handle for assets.
 *
 * @details
 *  As long as at least one @c StrongHandle exists for an asset,
 *  it will remain loaded. As soon as the number of handles reaches
 *  zero, a request will be made to purge the asset at the end of
 *  the frame. If then there are still no references, the asset
 *  will be removed.
 *
 * @tparam A The type of the asset this handle references.
 *
 */
template <typename A>
class StrongHandle {
public:
    using TypeID = WeakHandle::TypeID;

    /// @brief Returns a dummy AssetHandle.
    static auto invalid() noexcept -> StrongHandle { return StrongHandle{ }; }
    /// @brief Returns a new AssetHandle from a weak one.
    static auto from_weak(const WeakHandle& weak) noexcept -> StrongHandle {
        SIREN_ASSERT(
            weak.id().type() == AssetID::get_type_id<A>(),
            "WeakHandle type does not match StrongHandle<{}>",
            TypeName<A>::value()
        );
        auto* typed_pool = static_cast<AssetPool<A>*>(weak.pool());
        return StrongHandle{ weak.id(), typed_pool, weak.path() };
    }

    StrongHandle() = default;
    ~StrongHandle() { if (m_weak.pool()) { pool().dec_ref(id()); } }

    StrongHandle(
        const AssetID& id,
        AssetPool<A>* pool,
        const AssetPath& asset_path
    ) : m_weak(WeakHandle{ id, pool, asset_path }) {
        SIREN_ASSERT(
            AssetID::get_type_id<A>() == id.type(),
            "Cannot construct a StrongHandle if AssetID and AssetPool types do not match."
        );
        if (pool) { pool->inc_ref(id); }
    }

    StrongHandle(const StrongHandle& other) : m_weak(other.m_weak) { if (m_weak.pool()) { pool().inc_ref(id()); } }
    StrongHandle& operator=(const StrongHandle& other) {
        if (this != &other) {
            m_weak = other.m_weak;
            if (m_weak.pool()) { pool().inc_ref(id()); }
        }
        return *this;
    }

    StrongHandle(StrongHandle&& other) noexcept : m_weak(other.m_weak) { std::exchange(other.m_weak, WeakHandle{ }); }
    StrongHandle& operator=(StrongHandle&& other) noexcept {
        if (this != &other) {
            if (m_weak.pool()) {
                pool().dec_ref(id());
            }
            m_weak       = other.m_weak;
            other.m_weak = WeakHandle::invalid();
        }
        return *this;
    }

    /// @brief Returns a weak and type erased handle to the same asset.
    [[nodiscard]]
    constexpr auto as_weak() const noexcept -> WeakHandle { return m_weak; }
    /// @brief Checks if this handle is valid and references an alive asset.
    [[nodiscard]]
    auto is_valid() const -> bool { return id().is_valid() && m_weak.pool() != nullptr && pool().is_valid_id(id()); }

    /// @brief Returns the raw untyped version of this handle.
    [[nodiscard]]
    constexpr auto id() const noexcept -> AssetID { return m_weak.id(); }
    /// @brief Returns the typed AssetPool reference where the referenced asset is stored.
    [[nodiscard]]
    auto pool() const -> AssetPool<A>& { return *dynamic_cast<AssetPool<A>*>(m_weak.pool()); }
    /// @brief Returns the AssetPath of the referenced asset.
    [[nodiscard]]
    auto path() const -> AssetPath { return m_weak.path(); }

    [[nodiscard]]
    constexpr auto operator==(const StrongHandle& other) const -> bool { return id() == other.id(); }

private:
    WeakHandle m_weak; ///< @brief The internal weak handle.
};
} // namespace siren::core

template <>
struct std::hash<siren::core::WeakHandle> {
    auto operator()(const siren::core::WeakHandle& handle) const noexcept -> size_t { return handle.id().packed(); }
};

template <typename A>
struct std::hash<siren::core::StrongHandle<A>> {
    auto operator()(const siren::core::StrongHandle<A>& handle) const noexcept -> size_t {
        return handle.id().packed();
    }
};
